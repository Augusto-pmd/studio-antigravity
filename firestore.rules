/**
 * Core Philosophy: This ruleset implements a hybrid security model designed for a project management application.
 * It enforces strict user ownership for personal data while providing a secure foundation for project-related and master data.
 * The primary goal is strong authorization during prototyping, with flexibility in data schemas.
 *
 * Data Structure:
 * - /users/{userId}/*: All data directly related to a specific user (profile, cash accounts) is nested under their unique user ID. This provides a clear, path-based ownership structure.
 * - /projects/{projectId}/*: Project-specific data (details, expenses, contracts) is organized under a unique project ID. Access to this data tree is currently restricted pending schema updates.
 * - /suppliers, /categories: Top-level collections for master data, intended to be read by authenticated users but not modified by them.
 *
 * Key Security Decisions:
 * - User Data Segregation: All documents and subcollections under /users/{userId} are strictly private and can only be accessed by the authenticated owner. Listing all users is explicitly disallowed to protect privacy.
 * - Project Data Lockdown: The `Project` entity and its subcollections currently lack an `ownerId` or `members` field. To maintain security, all write operations (`create`, `update`, `delete`) on projects and their sub-data are disabled. Reads are permitted for any signed-in user. This is a temporary, secure default until the application schema is updated to include clear ownership or membership data for projects.
 * - Master Data is Read-Only: Collections like `suppliers` and `categories` are treated as read-only for application users. This prevents unauthorized modification of shared application data. An admin role or cloud function would be required for writes.
 * - Default Deny: Any access not explicitly granted is denied.
 *
 * Denormalization for Authorization:
 * These rules are architected with the principle of denormalization in mind. Authorization checks rely on data present directly in the document being accessed or in its path.
 * - Path-based ownership (`/users/{userId}`) is heavily used for fast, secure checks without needing extra database reads.
 * - The rules for project data are designed to eventually check for a denormalized `members` map or an `ownerId` field on the project document itself. This avoids slow and costly `get()` calls in subcollection rules.
 *
 * Structural Segregation:
 * The separation between private user data (`/users`) and shared project data (`/projects`) is a key structural decision. This simplifies security rules and makes it impossible for queries to accidentally leak data from one context to another.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if a parent project document exists. Used to secure access
     * to project subcollections.
     */
    function projectExists(projectId) {
      return exists(/databases/$(database)/documents/projects/$(projectId));
    }

    // ----------------------------------------------------------------------
    // User Data Rules
    // ----------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent listing all users for privacy
      allow create: if isOwner(userId);
      allow update, delete: if isOwner(userId);

      // --- Subcollections ---
      match /cash/{cashId} {
        allow read, write: if isOwner(userId);
      }
    }

    // ----------------------------------------------------------------------
    // Project Data Rules
    // ----------------------------------------------------------------------

    match /projects/{projectId} {
      allow get, list: if isSignedIn();
      // CRITICAL: Writes are disabled. The 'Project' entity lacks an `ownerId` or `members` field.
      // This is a secure default. Enable writes only after adding an ownership field to the schema.
      allow write: if false;

      // --- Subcollections ---
      match /expenses/{expenseId} {
        allow get, list: if isSignedIn() && projectExists(projectId);
        // CRITICAL: Write access depends on parent project ownership, which isn't defined.
        allow write: if false;
      }

      match /contracts/{contractId} {
        allow get, list: if isSignedIn() && projectExists(projectId);
         // CRITICAL: Write access depends on parent project ownership, which isn't defined.
        allow write: if false;
      }
    }

    // ----------------------------------------------------------------------
    // Master Data Rules
    // ----------------------------------------------------------------------

    match /suppliers/{supplierId} {
      allow get, list: if isSignedIn();
      // Master data should not be modifiable by clients.
      allow write: if false;
    }

    match /categories/{categoryId} {
      allow get, list: if isSignedIn();
       // Master data should not be modifiable by clients.
      allow write: if false;
    }
  }
}
