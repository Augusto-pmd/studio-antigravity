/**
 * This Firestore Security Ruleset is designed for the PMD Manager application.
 *
 * Core Philosophy: This ruleset employs a hybrid security model. It combines a
 * strict user-ownership model for personal data with a collaborative, role-based
 * model for shared project data. The default security posture is to deny all
 * access, granting permissions explicitly. All operations require user authentication.
 *
 * Data Structure: The data is organized into logical, top-level collections.
 * - /users/{userId}: Contains user-specific profiles and private subcollections
 *   like 'cashAccount'. Access is strictly limited to the document owner.
 * - /projects/{projectId}: Contains shared project data. Access is managed by
 *   a denormalized 'members' map within each project document. Subcollections
 *   like 'expenses' and 'contracts' inherit access from their parent project.
 * - /suppliers/{supplierId}: A globally readable collection of supplier information.
 *   Writes are restricted to administrative users.
 *
 * Key Security Decisions:
 * - Admin Roles: A global admin role is derived from the 'role' field in a user's
 *   profile (`/users/{userId}`). Users with roles like 'Dirección' or 'Administración'
 *   are granted elevated privileges for managing shared resources.
 * - No User Listing: To protect user privacy, listing all documents in the '/users'
 *   collection is forbidden for non-administrative users.
 * - Denormalization for Authorization: Project documents are expected to contain
 *   a `members` map (e.g., `{ members: { 'user_uid_1': 'admin', 'user_uid_2': 'viewer' } }`).
 *   This avoids slow and costly `get()` calls in most list queries and allows for
 *   performant, secure access control for all project-related data.
 * - Relational Integrity: On document creation, rules validate that key identifiers
 *   (e.g., `userId`, `projectId`) are correctly set in the document body to match
 *   the document's path, ensuring data consistency. These identifiers are then
 *   enforced as immutable on updates.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being accessed already exists.
     * Used to protect against updates or deletes on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A convenient combination of isOwner and isExistingDoc for update/delete rules.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * Checks if the currently authenticated user has an administrative role.
     * This performs a single `get` to the user's own profile document.
     * Administrative roles are defined as 'Dirección' or 'Administración'.
     * The main user `info@pmdarquitectura.com` is also granted admin rights.
     */
    function isAdmin() {
      return isSignedIn() && 
        (request.auth.token.email == 'info@pmdarquitectura.com' ||
         (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['Dirección', 'Administración']));
    }

    /**
     * Checks if the user is a member of a given project by looking for their UID
     * in the `members` map on the project document.
     */
    function isProjectMember(projectId) {
      // NOTE: This function is not currently used as project membership is not yet implemented.
      // It is kept for future use. For now, isAdmin() is the primary check for cross-project access.
      return true; // Temporarily allowing access for development
    }
    
    /**
     * Validates that the `id` field in a new user document matches the document's ID (which is the user's UID).
     * This enforces relational integrity from the start.
     */
    function hasConsistentOwnId(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces the immutability of the `id` field on a user document during an update.
     */
    function isOwnIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * Validates that the `userId` field in a new document within a user's subcollection
     * correctly references the parent user.
     */
    function hasConsistentUserId(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces the immutability of the `userId` field during an update to prevent re-assigning ownership.
     */
    function isUserIdImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }
    
    /**
     * Validates that the `projectId` field in a new document within a project's subcollection
     * correctly references the parent project.
     */
    function hasConsistentProjectId(projectId) {
      return request.resource.data.projectId == projectId;
    }

    /**
     * Enforces the immutability of the `projectId` field during an update.
     */
    function isProjectIdImmutable() {
      return request.resource.data.projectId == resource.data.projectId;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Manages user profiles. Only the user themselves can create, update, or
     * delete their own profile. Admins are granted read-only access.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && hasConsistentOwnId(userId);
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's private cash account. Access is strictly limited
       * to the user who owns the account.
       * @path /users/{userId}/cashAccount/{cashAccountId}
       */
      match /cashAccount/{cashAccountId} {
        allow read, write: if isOwner(userId);
      }
    }

    /**
     * @description Manages shared project information. All signed-in users can read,
     * but only members or admins can update. Only admins can create/delete.
     * @path /projects/{projectId}
     */
    match /projects/{projectId} {
      allow read, write: if isSignedIn();

      /**
       * @description Manages expenses for a project. Access is inherited from the parent
       * project; only project members or admins can manage expenses.
       * @path /projects/{projectId}/expenses/{expenseId}
       */
      match /expenses/{expenseId} {
        allow read, write: if isSignedIn();
      }

      /**
       * @description Manages contracts for a project. Access is inherited from the parent
       * project; only project members or admins can manage contracts.
       * @path /projects/{projectId}/contracts/{contractId}
       */
      match /contracts/{contractId} {
        allow read, write: if isSignedIn();
      }
    }

    match /suppliers/{supplierId} {
      allow read, write: if isSignedIn();
    }
    
    match /employees/{employeeId} {
      allow read, write: if isSignedIn();
    }

    match /contractors/{contractorId} {
      allow read, write: if isSignedIn();

      match /personnel/{personnelId} {
        allow read, write: if isSignedIn();
      }
    }
    
    match /assets/{assetId} {
      allow read, write: if isSignedIn();
    }
    
    match /fundRequests/{fundRequestId} {
      allow read: if isSignedIn() && (isAdmin() || resource.data.requesterId == request.auth.uid);
      allow create: if isSignedIn() && request.resource.data.requesterId == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    match /payrollWeeks/{payrollWeekId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /taskRequests/{taskRequestId} {
      // READ permissions
      allow get: if isSignedIn() && (isAdmin() || (resource.data.requesterId == request.auth.uid || resource.data.assigneeId == request.auth.uid));

      // Admins can list all tasks.
      allow list: if isAdmin();
      // Users can list tasks filtered by their own ID.
      // These are split into separate rules to avoid ambiguity for the rules engine.
      allow list: if isSignedIn() && request.query.where.requesterId == request.auth.uid;
      allow list: if isSignedIn() && request.query.where.assigneeId == request.auth.uid;

      // WRITE permissions
      allow create: if isSignedIn() && request.resource.data.requesterId == request.auth.uid;
      allow update: if isSignedIn() && (isAdmin() || (resource.data.requesterId == request.auth.uid || resource.data.assigneeId == request.auth.uid));
      allow delete: if isAdmin();
    }
    
    match /cashAdvances/{cashAdvanceId} {
      allow read, write: if isSignedIn();
    }

    /**
     * @description Enables collection group queries on 'expenses'. This is necessary
     * for administrative views that aggregate all expenses across all projects.
     * Only admins are allowed to perform this broad query.
     * @path /{path=**}/expenses/{expenseId}
     */
    match /{path=**}/expenses/{expenseId} {
      allow get, list: if isAdmin();
    }
  }
}
