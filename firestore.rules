/**
 * This Firestore Security Ruleset is designed for the PMD Manager application.
 *
 * Core Philosophy: This ruleset employs a hybrid security model. It combines a
 * strict user-ownership model for personal data with a collaborative, role-based
 * model for shared project data. The default security posture is to deny all
 * access, granting permissions explicitly. All operations require user authentication.
 *
 * Data Structure: The data is organized into logical, top-level collections.
 * - /users/{userId}: Contains user-specific profiles and private subcollections
 *   like 'cashAccount'. Access is strictly limited to the document owner.
 * - /projects/{projectId}: Contains shared project data. Access is managed by
 *   a denormalized 'members' map within each project document. Subcollections
 *   like 'expenses' and 'contracts' inherit access from their parent project.
 * - /suppliers/{supplierId}: A globally readable collection of supplier information.
 *   Writes are restricted to administrative users.
 *
 * Key Security Decisions:
 * - Admin Roles: A global admin role is derived from the 'role' field in a user's
 *   profile (`/users/{userId}`). Users with roles like 'Direction' or 'Administration'
 *   are granted elevated privileges for managing shared resources.
 * - No User Listing: To protect user privacy, listing all documents in the '/users'
 *   collection is forbidden for non-administrative users.
 * - Denormalization for Authorization: Project documents are expected to contain
 *   a `members` map (e.g., `{ members: { 'user_uid_1': 'admin', 'user_uid_2': 'viewer' } }`).
 *   This avoids slow and costly `get()` calls in most list queries and allows for
 *   performant, secure access control for all project-related data.
 * - Relational Integrity: On document creation, rules validate that key identifiers
 *   (e.g., `userId`, `projectId`) are correctly set in the document body to match
 *   the document's path, ensuring data consistency. These identifiers are then
 *   enforced as immutable on updates.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being accessed already exists.
     * Used to protect against updates or deletes on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A convenient combination of isOwner and isExistingDoc for update/delete rules.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * Checks if the currently authenticated user has an administrative role.
     * This performs a single `get` to the user's own profile document.
     * Administrative roles are defined as 'Direction' or 'Administration'.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['Dirección', 'Administración'];
    }

    /**
     * Checks if the user is a member of a given project by looking for their UID
     * in the `members` map on the project document.
     */
    function isProjectMember(projectId) {
      let projectData = get(/databases/$(database)/documents/projects/$(projectId)).data;
      return isSignedIn() && request.auth.uid in projectData.members;
    }
    
    /**
     * Validates that the `id` field in a new user document matches the document's ID (which is the user's UID).
     * This enforces relational integrity from the start.
     */
    function hasConsistentOwnId(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces the immutability of the `id` field on a user document during an update.
     */
    function isOwnIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * Validates that the `userId` field in a new document within a user's subcollection
     * correctly references the parent user.
     */
    function hasConsistentUserId(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces the immutability of the `userId` field during an update to prevent re-assigning ownership.
     */
    function isUserIdImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }
    
    /**
     * Validates that the `projectId` field in a new document within a project's subcollection
     * correctly references the parent project.
     */
    function hasConsistentProjectId(projectId) {
      return request.resource.data.projectId == projectId;
    }

    /**
     * Enforces the immutability of the `projectId` field during an update.
     */
    function isProjectIdImmutable() {
      return request.resource.data.projectId == resource.data.projectId;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Manages user profiles. Only the user themselves can create, update, or
     * delete their own profile. Admins are granted read-only access.
     * @path /users/{userId}
     * @allow (get) A user with uid 'user123' reads their own document at /users/user123.
     * @deny (update) A user with uid 'user456' tries to update /users/user123.
     * @principle Restricts access to a user's own data tree and allows self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && hasConsistentOwnId(userId);
      allow update: if isExistingOwner(userId) && isOwnIdImmutable();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's private cash account. Access is strictly limited
       * to the user who owns the account.
       * @path /users/{userId}/cashAccount/{cashAccountId}
       * @allow (create) A user with uid 'user123' creates a document in /users/user123/cashAccount/.
       * @deny (get) An admin tries to read a document in /users/user123/cashAccount/.
       * @principle Enforces strict document ownership within a private subcollection.
       */
      match /cashAccount/{cashAccountId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasConsistentUserId(userId);
        allow update: if isExistingOwner(userId) && isUserIdImmutable();
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Manages shared project information. All signed-in users can read,
     * but only members or admins can update. Only admins can create/delete.
     * @path /projects/{projectId}
     * @allow (get) A user whose UID is in the `members` map of project 'projAbc' reads /projects/projAbc.
     * @deny (create) A regular, non-admin user tries to create a new project document.
     * @principle Implements collaborative access via a denormalized members list.
     */
    match /projects/{projectId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isSignedIn();
      allow delete: if isAdmin();

      /**
       * @description Manages expenses for a project. Access is inherited from the parent
       * project; only project members or admins can manage expenses.
       * @path /projects/{projectId}/expenses/{expenseId}
       * @allow (list) A member of project 'projAbc' lists expenses at /projects/projAbc/expenses.
       * @deny (update) A user not in the `members` map of 'projAbc' tries to update an expense.
       * @principle Inherits authorization context from a parent document.
       */
      match /expenses/{expenseId} {
        allow get: if isProjectMember(projectId) || isAdmin();
        allow list: if isProjectMember(projectId) || isAdmin();
        allow create: if (isProjectMember(projectId) || isAdmin()) && hasConsistentProjectId(projectId);
        allow update: if (isProjectMember(projectId) || isAdmin()) && isExistingDoc() && isProjectIdImmutable();
        allow delete: if (isProjectMember(projectId) || isAdmin()) && isExistingDoc();
      }

      /**
       * @description Manages contracts for a project. Access is inherited from the parent
       * project; only project members or admins can manage contracts.
       * @path /projects/{projectId}/contracts/{contractId}
       * @allow (create) An admin creates a new contract under /projects/projAbc/contracts.
       * @deny (delete) A user not in the `members` map of 'projAbc' tries to delete a contract.
       * @principle Inherits authorization context from a parent document.
       */
      match /contracts/{contractId} {
        allow get: if isProjectMember(projectId) || isAdmin();
        allow list: if isProjectMember(projectId) || isAdmin();
        allow create: if (isProjectMember(projectId) || isAdmin()) && hasConsistentProjectId(projectId);
        allow update: if (isProjectMember(projectId) || isAdmin()) && isExistingDoc() && isProjectIdImmutable();
        allow delete: if (isProjectMember(projectId) || isAdmin()) && isExistingDoc();
      }
    }

    match /suppliers/{supplierId} {
      allow read, write: if isSignedIn();
    }
    
    match /employees/{employeeId} {
      allow read, write: if isSignedIn();
    }

    match /contractors/{contractorId} {
      allow read, write: if isSignedIn();

      match /personnel/{personnelId} {
        allow read, write: if isSignedIn();
      }
    }
    
    /**
     * @description Enables collection group queries on 'expenses'. This is necessary
     * for administrative views that aggregate all expenses across all projects.
     * Only admins are allowed to perform this broad query.
     * @path /{path=**}/expenses/{expenseId}
     */
    match /{path=**}/expenses/{expenseId} {
      allow get, list: if isAdmin();
    }
  }
}
